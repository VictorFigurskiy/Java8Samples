Видео с Youtube: https://www.youtube.com/watch?v=k6oh9C_71mE&list=PLlsMRoVt5sTPgGbinwOVnaF1mxNeLAD7P

Сайт с описанием паттернов: https://refactoring.guru/ru/design-patterns


Шаблонов много, но что-бы их понять, лучше пояснить для чего они нужны.
Вот как я понял:

******************************************************************************************************

Создающие (Creational) - Эти паттерны решают проблемы обеспечения гибкости создания объектовм

Фабрика (Factory) - Создание интерфеса, который создает объекты. При этой, выбор того, экземпляр какого класса создавать остается за классами, которые имплементируют данный интерфейс. Используется для делегирования создания экземпляров, другому классу. Обычно статический метод создания сложных классов
Абстраксная Фабрика (Abstract Factory) - Создание интерфеса, для создания множества взаимосвязанных или взаимнозависимых объектов, без жесткой привязки к конктретным классам. Используется для создания множеств взаимносвязных объектов.
Строитель (Builder) - Отделить конструирование сложного обьекта от его представления таким образом, чтобы в результате одного и того же конструированиия мы могли получить разные представления. Используется для создания различных объектов из одного набора данных.
Прототип (Prototype) - Определить вид создавемых объектов с помощью экземпляра - прототипа и создавать новые объекты, копируя этот прототип. Используется для копий заданного объекта.
Синглтон (Singleton) - Гарантировать, что у класса будет только один единственный экземпляр и к нему будет предоставлена глобальная точка доступа. Используется для создания единственного экземпляра определенного класса.

******************************************************************************************************

Структурные (Structural) - Эти паттерны решают проблемы эффективного построения связей между объектами

Заместитель, Прокси (Proxy) - Для замещения другого объекта и контроля доступа к нему. Используется для обеспечения контроля доступа к определенному объекту, также возможно добавление своей логики в процесс (например логирование)
Декоратор (Decorator) - Динамическое добавление новых обязанностей объекту. Используется в качестве альтернптивы порождению подклассов для расширения фуункциональности. Паттерн Декоратор – шаблон проектирования, предназначенный для динамического подключения к объекту дополнительного поведения. Паттерн Декоратор представляет гибкую альтернативу практике создания подклассов с целью расширения функциональности. Добавление своей логики без изменения логики работы старого или очень критичного класса. Относится ко второму принципу SOLID "Классы должны быть открыты для расширения, но закрыты для изменений"
Адаптер (Adapter) - Преобразование интерфейса одного класса в интерфейс того класса, который необходим клиенту. Используется для обеспечения работы классов, интерфейсы которых несовместимы. Для соединения разных классов, адаптация одного класса для другого
Компоновщик (Composite) - Скомпонировать объекты в структуру по типу "Дерева", позволяя клиентам трактовать отдельные и составные объекты. Используется для группировки мелких компонентов в более крупные, которые, в свою очередь, могут стать основой для еще более крупных структур.
Мост (Bridge) - Отделить абстракцию от ее реализации таким образом, чтобы мы могли изменять независимо друг от друга и то и другое. Используется для получения преимуществ наследования без потерь гибкости. Позволяет абстрактным методам (открыть, записать, закрыть и т.д.) работать в разных реализациях (windows, linux)
Фасад (Facade) - Предоставляет унифицированный интрефейс вместо нескольких интерфейсов подсистемы. Используется для определения интерфейса высокого уровня, который упрощает использование подсистем.
Приспособленец (Flyweight) - Поддержка множества мелких объектов. Использует разделения для того, чтобы поддерживать много мелких объектов.

******************************************************************************************************

Поведенческие (Behavioral) - Эти паттерны решают проблемы эффективного взаимодействия между объектами

Стратегия (Strategy) - Взаимозаменяемость семейства классов. Используется для определения семейства классов, инкапсулирование каждого из них и организация их взаимозаменяемости. В зависимости от признака выполняет нужную стратегию
Состояние (State) - Управление поведением объекта в зависимости от состояния. Позволяет нам управлять поведением объекта в зависимости от внутреннего состояния объекта.
Команда (Command) - Инкапсулирование запроса в объект. Используется чтобы задать параметры клиентов для обработки определенных запросов, создание очереди из этих запросов или их контроля и поддержки отмены операций. В зависимости от признака выполняет нужное действие
Интерпретатор (Interpreter) - Определение представления граматики объекта. Используется для определения представления граматики заданного языка и интерпритации его предложений.
Цепочка обязанностей (Chain of Responsibilities) - Связывание объектов-получателей в цепочку и передача запроса по ней. Используется для того чтобы избежать привязки отправителя запроса к его получателю, что дает возможность обработать данный запрос нескольким обьектам. Добавление в процесс множества промежуточных действий (например фильтров или уведомлений в зависимости от важноости)
Итератор (Iterator) - Получение последовательного доступа ко всем элементам составного объекта. Используется для получения последовательного доступа ко всем элементам составного объекта, скрывая его внутреннее представление.
Посетитель (Visitor) - Описание действий, которые выполняются с каждым объектом в некоторой структуре. Используется для описания операций, которые выполняются с каждым объетком из некоторой структуры. Позволяет определить новую операцию без изменения пподклассов этих объектов.
Наблюдатель (Observer) - Определение зависимости "один ко многим" между объектами. Используется для определение зависимости "один ко многим" между объектами таким образом, что при изменении состояния одного объекта все зависящие от него объекты были уведомленыи об этом и обновились. Один субъект и много наблюдателей. подписываемся на какое-нибудь событие происходящее с определенным объектом, для реагирования
Посредник (Mediator) - Инкапсуляция способа взаимодействия множества объектов. Используется для определения объекта, который инкапсулирует способ взаимодействия множества объектов и обеспечения слабой связи между этими объектами. класс через который удобно работать с объектами в сложной системе
Шаблонный метод (Template) - Определение основы класса и создание возможности подклассам переопределять его части. Используется для определения основы класса и позволяет подклассам переопределять некоторые его части не изменяя его структуру в целом.
Снимок, Хранитель (Memento) - Сохранить внутреннее состояние объекта за его пределы. Используется для фиксирования внутреннего состояния объекта за его пределами не нарушая инкапсуляцию и востановление объекта в случае необходимости. текущее состояние объекта для сохранения/загрузки

******************************************************************************************************