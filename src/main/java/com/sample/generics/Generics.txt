Вывод по дженерикам своими словами:

кароче мой короткий вывод, поправь если не так
выходит что в байткоде дженериков нет
по сути механизм строго для комплятора

Ну да, типовая безопасность, он проверяет что все типы на месте, а потом делает грубое приведение
тупо кастит типы

и когда я укажу ? super Number или  ? extends Number то это скорее проверка ссылочного типа который я хочу ему притулить

Ну да, на момент компиляции вся инфа про дженерики стирается

при этом extends - read only, super - read/write

        List<? extends Number> nums = new ArrayList<>();
        nums.add(null);
        nums.add(3.14); // compile-time error

        Если контейнер объявлен с wildcard ? extends, то можно только читать значения.
        В список нельзя ничего добавить, кроме null.
        Для того чтобы добавить объект в список нам нужен другой тип wildcard — ? super

и дальше в коллекции могу продолжать работать только с центровым указанным типоа от которого и выбираются границы

я кодом покажу

List<Number> ints5 = new ArrayList<>();
ints.add(1);

List<? super Double> nums5 = ints5;
nums5.add(12D);

так я могу и дальше расширять эту ебалу
но Number уже нет, так как наследование в самой кколекции уже до лампочки и по сути привязка уже идет по типу List<Double> nums5
как то так я понимаю? Или не совсем

Я еще раз говорю когда пишешь super или extends ето не влияет на то что ты ложишь в коллекцию,
но влияет на то какие сслыки ты присваиваешь, на даном примере коллекция знает про Double и вот как ты сказал может добавлять только его


попробуй вот так сделать еще

List<? super Double> nums2 = new ArrayList<>();
Object object = nums2.get(0) // вернем только Object тоесть в таком смысле это просто List<Object>, но с ограничением по нижней границе